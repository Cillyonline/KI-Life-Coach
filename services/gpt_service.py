"""GPT integration service for reflective dialogues."""

from __future__ import annotations

import json
import logging
import os
from dataclasses import dataclass
from hashlib import sha256
from pathlib import Path
from typing import Any

import openai

logger = logging.getLogger(__name__)


@dataclass
class GPTService:
    """Service class for generating reflective GPT responses.

    Attributes:
        model: Name of the OpenAI model to use.
        log_path: Path to the JSON file where anonymized interactions are stored.
    """

    model: str = "gpt-3.5-turbo"
    log_path: Path = Path("data") / "gpt_logs.json"

    def __post_init__(self) -> None:
        """Configure the OpenAI API key and ensure the log path exists."""
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise RuntimeError("OPENAI_API_KEY is not set")
        openai.api_key = api_key
        self.log_path.parent.mkdir(parents=True, exist_ok=True)

    def generate_reflection(self, prompt: str, user_id: int, style: str = "motivierend") -> str:
        """Generate a reflective message using GPT.

        Args:
            prompt: The user-specific prompt containing mood or journal data.
            user_id: Telegram user identifier used for anonymized logging.
            style: Desired reflection style (e.g., motivierend, analytisch, humorvoll).

        Returns:
            The text response generated by GPT.

        Raises:
            RuntimeError: If the GPT request fails for any reason.
        """
        system_prompt = (
            "Ziel: Unterstütze den Nutzer mit einer kurzen Reflexion. "
            "Kontext: Du bist ein einfühlsamer Coach und sollst im Stil '"
            f"{style}' antworten. Frage: {prompt} Ausgabeformat: Reiner Text."
        )
        try:
            response: Any = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": prompt},
                ],
                timeout=30,
            )
            message = response["choices"][0]["message"]["content"].strip()
            self._log_interaction(user_id, prompt, message)
            return message
        except openai.error.OpenAIError as exc:  # type: ignore[attr-defined]
            logger.error("OpenAI API error: %s", exc)
            raise RuntimeError("Fehler beim Abrufen der Reflexion.") from exc
        except Exception as exc:
            logger.exception("Unexpected error during GPT request")
            raise RuntimeError("Unerwarteter Fehler bei der Reflexion.") from exc

    def _log_interaction(self, user_id: int, prompt: str, response: str) -> None:
        """Persist anonymized GPT interactions to ``log_path``.

        Args:
            user_id: Telegram user identifier used for anonymization.
            prompt: Prompt sent to the GPT model.
            response: Response received from the GPT model.
        """
        try:
            hashed = sha256(str(user_id).encode()).hexdigest()
            data = {}
            if self.log_path.exists():
                try:
                    data = json.loads(self.log_path.read_text())
                except json.JSONDecodeError:
                    logger.warning("Could not decode existing GPT log file; starting new one")
            entries = data.get(hashed, [])
            entries.append({"prompt": prompt, "response": response})
            data[hashed] = entries[-5:]
            self.log_path.write_text(json.dumps(data, ensure_ascii=False, indent=2))
        except Exception:
            logger.exception("Failed to log GPT interaction")
